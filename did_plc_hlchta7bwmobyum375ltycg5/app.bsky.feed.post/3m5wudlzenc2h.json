{
  "did": "did:plc:hlchta7bwmobyum375ltycg5",
  "time_us": 1763507455023177,
  "kind": "commit",
  "commit": {
    "rev": "3m5wudprsmj2y",
    "operation": "create",
    "collection": "app.bsky.feed.post",
    "rkey": "3m5wudlzenc2h",
    "record": {
      "$type": "app.bsky.feed.post",
      "createdAt": "2025-11-18T23:10:50.128Z",
      "embed": {
        "$type": "app.bsky.embed.external",
        "external": {
          "description": "Alt: So, apparently it's _always_ been easy to do byte buffer manipulation in PowerShell and none of us ever noticed.\n\nWe've always been able to strongly type an array.\n\nWe've always been able to multiply arrays.\n\nOf course this would work.\n\nThis always has worked.\n\nIt always will work.\n\nAnd it opens up _so_ many doors.\n\nBasically we can read and write binary formats in PowerShell by a very small amount of clever byte math (just the way early C developers intended)\n\nSo, this is fun, especially when combined with hex notation.\n\nHave fun with two of the most insanely simple lines you've ever seen.\n\nMake sure to put the type before the variable name, so PowerShell strongly types the variable!\n\nMake sure to expand the array in a second statement to keep things speedy.\n\nHope this helps, and don't do anything too crazy!",
          "thumb": {
            "$type": "blob",
            "ref": {
              "$link": "bafkreihron4ibotgobhe6x4edcjb6wn6nlb26r5jye5oc7xcxtdyhdlp5m"
            },
            "mimeType": "image/jpeg",
            "size": 726750
          },
          "title": "a close up of a woman 's face with a surprised look on her face .",
          "uri": "https://media.tenor.com/rReKAT-J3nsAAAAC/mind-blown-boom.gif?hh=371&ww=498"
        }
      },
      "facets": [
        {
          "features": [
            {
              "$type": "app.bsky.richtext.facet#tag",
              "tag": "Bitmap"
            }
          ],
          "index": {
            "byteEnd": 51,
            "byteStart": 44
          }
        },
        {
          "features": [
            {
              "$type": "app.bsky.richtext.facet#tag",
              "tag": "PowerShell"
            }
          ],
          "index": {
            "byteEnd": 73,
            "byteStart": 62
          }
        },
        {
          "features": [
            {
              "$type": "app.bsky.richtext.facet#tag",
              "tag": "GameDev"
            }
          ],
          "index": {
            "byteEnd": 84,
            "byteStart": 76
          }
        },
        {
          "features": [
            {
              "$type": "app.bsky.richtext.facet#tag",
              "tag": "Graphics"
            }
          ],
          "index": {
            "byteEnd": 94,
            "byteStart": 85
          }
        },
        {
          "features": [
            {
              "$type": "app.bsky.richtext.facet#tag",
              "tag": "Tip"
            }
          ],
          "index": {
            "byteEnd": 99,
            "byteStart": 95
          }
        },
        {
          "features": [
            {
              "$type": "app.bsky.richtext.facet#tag",
              "tag": "Trick"
            }
          ],
          "index": {
            "byteEnd": 106,
            "byteStart": 100
          }
        },
        {
          "features": [
            {
              "$type": "app.bsky.richtext.facet#tag",
              "tag": "FYI"
            }
          ],
          "index": {
            "byteEnd": 111,
            "byteStart": 107
          }
        }
      ],
      "langs": [
        "en"
      ],
      "text": "I just figured out how easy it is to make a #Bitmap buffer in #PowerShell!\n\n#GameDev #Graphics #Tip #Trick #FYI\n\nJust strongly type & multiply by resolution! ðŸ¤¯\n\n[byte[]]$rgba = (0x44,0x88,0xff,0xff)\n$rgba *= 1920 * 1080\n\nWe can read with ranges and change bytes! ðŸ¤¯\n\n$rgba[0..(1920 * 4)]\n$rgba[0]++\n\nðŸ˜Ž"
    },
    "cid": "bafyreigtjgss6dkhnvtulrsmupqtcvwm4bjglsv53pwzbhyc4qac6hnkum"
  }
}